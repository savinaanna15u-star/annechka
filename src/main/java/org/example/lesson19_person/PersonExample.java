package org.example.lesson19_person;

public class PersonExample {

    public static void main(String[] args) {
        Person ivan = new Person(1, "Ivan", "Ivanov");
        Person petr = new Person(1, "Ivan", "Ivanov");
//        Person petr = new Person(2, "Petr", "Petrov");


        System.out.println(ivan.hashCode());
        System.out.println(petr.hashCode());
        System.out.println(ivan.equals(petr)); // переопределили метод equals(), и теперь проверяет не ссылки, а значения
    }
}

// контракт метода equals:
//1. рефлективность а = а
//2. симметричность
//3. транзитивность а = б, б = с, а = с
//4. повторяемость/консистентность

// hashCode
// 1. у двух одинаковых объектов, должен быть одинаковый хеш код
// 2. у двух разных объектов, могут быть одинаковый хеш код
// нельзя возвращать константу или рандомное число



// 1. Объясните контракт между equals() и hashCode() методами в Java
// - если два объекта равны через equals(), их hashCode() тоже должен быть одинаковым
// - контракт equals: рефлективность, симметричность, транзитивность, повторяемость
// - контракт hashCode: если равны через equals, должны иметь одининаковый хеш, если не равны, хеш может совпасть - коллизия

// 2. Какая разница между equals() и hashCode()?
// - equals() по умолчанию сравнивает объекты через ссылки, а если переопределен, то выбранные поля
// - hashCode генерирует хеш код объекта

// 3. Почему необходимо переопределять оба метода вместе?
// - коллекции сначала ищут по  hashCode, а потом по equals. если объекты равны по equals, но их хеш коды разные,
// то для коллекции это разные объекты
//  нужно, чтобы объекты с равными полями выдавали одинаковый hashCode()

// 4. Что произойдёт, если переопределить только equals(), но не hashCode()?
// -  равные объекты по содержимому, будут иметь разный hashCode => объекты в коллекции не будут равны

// 5. Что произойдёт, если переопределить только hashCode(), но не equals()?
// - объекты с одинаковыми hashCode, но с разными данными, не будут равны, тк equals по дефолту будет сравнивать ссылки на объекты

// 6. Если два объекта имеют одинаковый hashCode(), означает ли это, что они равны?
// - не всегда, иногда два разных объекта могут иметь одинаковый hashCode()

// 7. Как использовать утилиту Objects.hash() для упрощения реализации hashCode()?
// - в методе hashCode() можно записать: return Objects.hash(name, id);

// 8. Должны ли методы equals() и hashCode() использовать одни и те же поля?
// - да, должны, иначе нарушится контракт
