package org.example.lesson11;


// Laptop <- Computer <- Object (если конструктор без параметров, то super можно пропустить)
public final class Laptop extends Computer { //класс Laptop наследует (extends)  Computer (extends)
    // при наследовании мы обязаны использовать какой то конструктор, который имеется в базовом(родительский) классе!
    // Если родительский класс реализует конструктор, то child класс обязан его реализовать
    // дочерний класс не обязан реализовывать (создавать) столько же конструкторов, сколько их определено в родительском классе
    // Если конструктор родителя помечен как private, то дочерний класс не может вызвать его напрямую и не обязан его реализовывать
    // в конструкторе наследнике обяз. вызвать конструктор базового класса, через super, первой строчкой вызвать базовый класс
    // можно наследовать только 1 класс
    // final - запрет наследования от Laptop
    private int weight;

    {
        System.out.println("init block laptop"); // доинициализировать этот объект
    }

    static {
        System.out.println("static block laptop");
    }

    public Laptop(Ssd ssd, Ram ram, int weight) {
        super(ssd, ram); // super - вызывает конструктор parent класса
        // само наследование происходит через extends ClassName
        //в конструктор Laptop передаем ссылку на объекты Ssd/ Ram, которые дальше прокидываются в parent конструктор Computer
        this.weight = weight; // this - ссылка на экземпяр текущего класса
    }

    public Laptop() {
        System.out.println("Constructor laptop");
    }

    @Override  // переопределение метода из базового класса
    // Переопределение - ключевой смысл полиморфизма
    //Слово «полиморфизм» происходит из греческого языка и означает «многообразие» или «много форм»: poly (много) + morphism (формы/типы).
    // Главное свойство полиморфизма заключается в том, что одна функция или метод может обрабатывать различные типы объектов и классов без знания
    // их конкретной природы

    public void load() {
        open();
        System.out.println("Я загрузился");
    }

    @Override
    public void print() {
        super.print();
        System.out.println("weight = " + weight);
    }

    public void open() {
        System.out.println("Я открыл крышку");
    }

    public int getWeight() {
        return weight;
    }
}

// alt + enter - вызвать меню для исправления ошибки компиляции

// 4 ПРИНЦИПА ООП:

//1. ИНКАПСУЛЯЦИЯ - Инкапсуляция — это принцип сокрытия внутренней реализации объекта и предоставления контролируемого доступа
// к его данным через методы. Это достигается с помощью модификаторов доступа: private, protected, public

//2. НАСЛЕДОВАНИЕ - механизм, позволяющий создавать новые классы на основе существующих, перенимая их свойства и поведение.
// Класс, от которого наследуются другие, называется родительским (суперклассом), а классы-наследники — подклассами(дочерними )

//3. ПОЛИМОРФИЗМ  - способность объекта принимать разные формы и одного интерфейса использоваться для объектов разных типов.
// Существует два вида полиморфизма: компиляции (перегрузка методов) и выполнения (переопределение методов)

//4. АБСТРАКЦИЯ - принцип сокрытия сложных деталей реализации и предоставления пользователю только необходимой информации.
// В Java абстракция реализуется через абстрактные классы и интерфейсы (public abstract class ... )

//Инкапсуляция защищает данные объектов
//
//Наследование позволяет переиспользовать код и создавать иерархии
//
//Полиморфизм обеспечивает гибкость и масштабируемость
//
//Абстракция скрывает сложность и предоставляет чистый интерфейс